import{_ as r,V as n,W as a,X as e,Y as t,$ as o,Z as l,F as s}from"./framework-44a66fc7.js";const i={},c=e("h1",{id:"数据类型",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#数据类型","aria-hidden":"true"},"#"),t(" 数据类型")],-1),h={href:"https://go.dev/ref/spec#Types",target:"_blank",rel:"noopener noreferrer"},g=l(`<br><h2 id="布尔类型" tabindex="-1"><a class="header-anchor" href="#布尔类型" aria-hidden="true">#</a> 布尔类型</h2><p>布尔类型只有真值和假值。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>bool</strong></td><td><code>true</code>为真值，<code>false</code>为假值</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">提示</p><p>在Go中，整数0并不代表假值，非零整数也不能代表真值，即数字无法代替布尔值进行逻辑判断，两者是完全不同的类型。</p></div><br><h2 id="整型" tabindex="-1"><a class="header-anchor" href="#整型" aria-hidden="true">#</a> 整型</h2><p>Go中为不同位数的整数分配了不同的类型，主要分为无符号整型与有符号整型。</p><table><thead><tr><th style="text-align:left;">序号</th><th style="text-align:left;">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>uint8</strong></td><td style="text-align:left;">无符号 8 位整型</td></tr><tr><td style="text-align:left;"><strong>uint16</strong></td><td style="text-align:left;">无符号 16 位整型</td></tr><tr><td style="text-align:left;"><strong>uint32</strong></td><td style="text-align:left;">无符号 32 位整型</td></tr><tr><td style="text-align:left;"><strong>uint64</strong></td><td style="text-align:left;">无符号 64 位整型</td></tr><tr><td style="text-align:left;"><strong>int8</strong></td><td style="text-align:left;">有符号 8 位整型</td></tr><tr><td style="text-align:left;"><strong>int16</strong></td><td style="text-align:left;">有符号 16 位整型</td></tr><tr><td style="text-align:left;"><strong>int32</strong></td><td style="text-align:left;">有符号 32 位整型</td></tr><tr><td style="text-align:left;"><strong>int64</strong></td><td style="text-align:left;">有符号 64 位整型</td></tr><tr><td style="text-align:left;"><strong>uint</strong></td><td style="text-align:left;">无符号整型 至少32位</td></tr><tr><td style="text-align:left;"><strong>int</strong></td><td style="text-align:left;">整型 至少32位</td></tr><tr><td style="text-align:left;"><strong>uintptr</strong></td><td style="text-align:left;">是一个足够大的整数类型，足以容纳任何位数的整数指针（特殊用途）。</td></tr></tbody></table><br><h2 id="浮点型" tabindex="-1"><a class="header-anchor" href="#浮点型" aria-hidden="true">#</a> 浮点型</h2><p><code>IEEE-754</code>浮点数，主要分为单精度浮点数与双精度浮点数。</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>float32</strong></td><td style="text-align:left;">IEEE-754 32位浮点型数</td></tr><tr><td style="text-align:left;"><strong>float64</strong></td><td style="text-align:left;">IEEE-754 64位浮点型数</td></tr></tbody></table><br><h2 id="复数类型" tabindex="-1"><a class="header-anchor" href="#复数类型" aria-hidden="true">#</a> 复数类型</h2><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>complex128</strong></td><td>64位实数和虚数</td></tr><tr><td><strong>complex64</strong></td><td>32位实数和虚数</td></tr></tbody></table><br><h2 id="字符类型" tabindex="-1"><a class="header-anchor" href="#字符类型" aria-hidden="true">#</a> 字符类型</h2><p>go完全兼容<code>UTF-8</code>。</p><table><thead><tr><th>类型</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td><strong>byte</strong></td><td style="text-align:left;">等价 <code>uint8</code> 可以表达ANSCII字符</td></tr><tr><td><strong>rune</strong></td><td style="text-align:left;">等价 <code>int32</code> 可以表达Unicode字符</td></tr><tr><td><strong>string</strong></td><td style="text-align:left;">字符串即字节序列，可以转换为<code>[]byte</code>类型即字节切片</td></tr></tbody></table><br><h2 id="派生类型" tabindex="-1"><a class="header-anchor" href="#派生类型" aria-hidden="true">#</a> 派生类型</h2><table><thead><tr><th>类型</th><th>例子</th></tr></thead><tbody><tr><td><strong>数组</strong></td><td><code>[5]int</code>，长度为5的整型数组</td></tr><tr><td><strong>切片</strong></td><td><code>[]float64</code>，64位浮点数切片</td></tr><tr><td><strong>映射表</strong></td><td><code>map[string]int</code>，键为字符串类型，值为整型的映射表</td></tr><tr><td><strong>结构体</strong></td><td><code>type Gopher struct{}</code>，Gopher结构体</td></tr><tr><td><strong>指针</strong></td><td><code>*int</code>，整型指针</td></tr><tr><td><strong>函数</strong></td><td><code>func()</code>，一个没有参数，没有返回值的函数类型</td></tr><tr><td><strong>接口</strong></td><td><code>type Gopher interface{}</code>，Gopher接口</td></tr><tr><td><strong>通道</strong></td><td><code>chan int</code>，整型通道</td></tr></tbody></table><h2 id="零值" tabindex="-1"><a class="header-anchor" href="#零值" aria-hidden="true">#</a> 零值</h2><p>官方文档中零值称为<code>zero value</code>，零值并不仅仅只是字面上的数字零，而是一个类型的空值或者说默认值更为准确。</p><table><thead><tr><th>类型</th><th>零值</th></tr></thead><tbody><tr><td>数字类型</td><td><code>0</code></td></tr><tr><td>布尔类型</td><td><code>false</code></td></tr><tr><td>字符串类型</td><td><code>&quot;&quot;</code></td></tr><tr><td>数组</td><td>固定长度的对应类型的零值集合</td></tr><tr><td>结构体</td><td>内部字段都是零值的结构体</td></tr><tr><td>切片，映射表，函数，接口，通道，指针</td><td><code>nil</code></td></tr></tbody></table><br><h3 id="nil" tabindex="-1"><a class="header-anchor" href="#nil" aria-hidden="true">#</a> nil</h3><p>源代码中的<code>nil</code>，可以看出<code>nil</code>仅仅只是一个变量。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> <span class="token boolean">nil</span> Type
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Go中的<code>nil</code>并不等同于其他语言的<code>null</code>，<code>nil</code>仅仅只是一些类型的零值，并且不属于任何类型，所以<code>nil == nil</code>这样的语句是无法通过编译的。</p>`,31);function f(y,b){const d=s("ExternalLinkIcon");return n(),a("div",null,[c,e("p",null,[t("下面列出Go语言中全部的内置类型，以供参考，更多细节可以前往"),e("a",h,[t("参考手册-类型"),o(d)]),t("。")]),g])}const p=r(i,[["render",f],["__file","10.datatype.html.vue"]]);export{p as default};
