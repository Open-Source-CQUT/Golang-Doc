# 切片

在Go中，数组和切片两者看起来长得几乎一模一样，但功能有着不小的区别，数组是定长的数据结构，长度被指定后就不能被改变，而切片是不定长的，切片在容量不够时会自行扩容。



## 数组

如果事先就知道了要存放数据的长度，且后续使用中不会有扩容的需求，就可以考虑使用数组。

::: tip

Go中的数组是值类型，也就是说数组是一个单独的类型，并不是指向头部元素的指针

:::

### 初始化

先来初始化一个长度为5的整型数组

```go
var nums [5]int
```

也可以用元素初始化

```go
nums := [5]int{1, 2, 3}
```

还可以通过`new`函数获得一个指针

```go
nums := new([5]int)
```

以上几种方式都会给`nums`分配一片固定大小的内存，区别只是最后一种得到的值是指针。

<br/>

在数组初始化时，需要注意的是，**长度必须为一个常量表达式**，否则将无法通过编译，常量表达式即表达式的最终结果是一个常量，错误例子如下：

```go
length := 5 // 这是一个变量
var nums [length]int
```

`length`是一个变量，因此无法用于初始化数组长度，如下是正确示例：

```go
const length = 5
var nums [length]int // 常量
var nums2 [length + 1]int // 常量表达式
var nums3 [(1 + 2 + 3) * 5]int // 常量表达式
var nums4 [5]int // 最常用的
```



### 使用

只要有数组名和下标，就可以访问数组中对应的元素。

```go
fmt.Println(nums[0])
```

同样的也可以修改数组元素

```go
nums[0] = 1
```

还可以通过内置函数`len`来访问数组元素的数量

```go
len(nums)
```

内置函数`cap`来访问数组容量，数组的容量等于数组长度，容量对于切片才有意义。

```go
cap(nums)
```



### 切割

切割数组的格式为`arr[startIndex:endIndex]`，切割的区间为**左闭右开**，例子如下：

```go
nums := [5]int{1, 2, 3, 4, 5}
nums[1:] // 子数组范围[1,5) ->1 2 3 4
nums[:5] // 子数组范围[0,5) -> 0 1 2 3 4
nums[2:3] // 子数组范围[2,3) -> 2
nums[1:3] // 子数组范围[1,3) -> 1 2
```



## 切片

切片在Go中应用的更加广泛一些，用于存放不知道长度的数据，且后续使用过程中可能会频繁的插入和删除元素。 

<br>

### 初始化

切片的初始化方式有以下几种

```go
var nums []int // 值
nums := []int{1, 2, 3} // 值
nums := make([]int, 0, 0) // 值
nums := new([]int) // 指针
```

可以看到切片与数组在外貌上的区别，仅仅只是少了一个初始化长度。通常情况下，推荐使用`make`来创建一个空切片，只是对于切片而言，`make`函数接收三个参数：类型，长度，容量。举个例子解释一下长度与容量的区别，假设有一桶水，水并不是满的，桶的高度就是桶的容量，代表着总共能装多少高度的水，而桶中水的高度就是代表着长度，水的高度一定小于等于桶的高度，否则水就溢出来了。所以，切片的长度代表着切片中元素的个数，切片的容量代表着切片总共能装多少个元素，切片与数组最大的区别在于切片的容量会自动扩张，而数组不会，更多细节前往[参考手册 - 长度与容量](https://go.dev/ref/spec#Length_and_capacity)。

::: tip

切片的底层实现依旧是数组，是引用类型，可以简单理解为是指向底层数组的指针。

:::

通过`var nums []int`这种方式声明的切片，默认值为`nil`，所以不会为其分配内存，而在使用`make`进行初始化时，建议预分配一个足够的容量，可以有效减少后续扩容的内存消耗。



### 使用

切片的基本使用与数组完全一致，区别只是切片可以动态变化长度，下面看几个例子。

切片可以通过`append`函数实现许多操作，函数签名如下，`slice`是要添加元素的目标切片，`elems`是待添加的元素，返回值是添加后的切片。

```go
func append(slice []Type, elems ...Type) []Type
```

首先创建一个长度为0，容量为0的空切片，然后在尾部插入一些元素，最后输出长度和容量。

```go
nums := make([]int, 0, 0)
nums = append(nums, 1, 2, 3, 4, 5, 6, 7)
fmt.Println(len(nums), cap(nums)) // 7 8 可以看到长度与容量并不一致。
```



### 插入元素

切片元素的插入也是需要结合`appned`函数来使用，现有切片如下，

```go
nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

从头部插入元素

```go
nums = append([]int{-1, 0}, nums...)
fmt.Println(nums) // [-1 0 1 2 3 4 5 6 7 8 9 10]
```

从中间下标i插入元素

```go
nums = append(nums[:i+1], append([]int{999, 999}, nums[i+1:]...)...)
fmt.Println(nums) // i=3，[1 2 3 4 999 999 5 6 7 8 9 10]
```

从尾部插入元素，就是`append`最原始的用法

```go
nums = append(nums, 99, 100)
fmt.Println(nums) // [1 2 3 4 5 6 7 8 9 10 99 100]
```



### 删除元素

切片元素的删除需要结合`append`函数来使用，现有如下切片

```go
nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

从头部删除n个元素

```go
nums = nums[n:]
fmt.Println(nums) //n=3 [4 5 6 7 8 9 10]
```

从尾部删除n个元素

```go
nums = nums[:len(nums)-n]
fmt.Println(nums) //n=3 [1 2 3 4 5 6 7]
```

从中间指定下标i位置开始删除n个元素

```go
nums = append(nums[:i], nums[i+n:]...)
fmt.Println(nums)// i=2，n=3，[1 2 6 7 8 9 10]
```

删除所有元素

```go
nums = nums[:0]
fmt.Println(nums) // []
```



### 拷贝

切片在拷贝时需要确保目标切片**有足够的长度**，例如

```go
func main() {
	dest := make([]int, 0)
	src := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	fmt.Println(src, dest)
	fmt.Println(copy(dest, src))
	fmt.Println(src, dest)
}
```

```
[1 2 3 4 5 6 7 8 9] []
0                     
[1 2 3 4 5 6 7 8 9] []
```

将长度修改为10，输出如下

```
[1 2 3 4 5 6 7 8 9] [0 0 0 0 0 0 0 0 0 0]
9                                        
[1 2 3 4 5 6 7 8 9] [1 2 3 4 5 6 7 8 9 0]
```



### 遍历

切片的遍历与数组完全一致，`for`循环

```go
func main() {
   slice := []int{1, 2, 3, 4, 5, 7, 8, 9}
   for i := 0; i < len(slice); i++ {
      fmt.Println(slice[i])
   }
}
```

`for range`循环

```go
func main() {
	slice := []int{1, 2, 3, 4, 5, 7, 8, 9}
	for index, val := range slice {
		fmt.Println(index, val)
	}
}
```



## 多维切片

先来看下面的一个例子，官方文档也有解释：[Effective Go - 二维切片](https://go.dev/doc/effective_go#two_dimensional_slices)

```go
var nums [5][5]int
for _, num := range nums {
   fmt.Println(num)
}
fmt.Println()
slices := make([][]int, 5)
for _, slice := range slices {
   fmt.Println(slice)
}
```

输出结果为

```
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]

[]
[]
[]
[]
[]
```

可以看到，同样是二维的数组和切片，其内部结构是不一样的。数组在初始化时，其一维和二维的长度早已固定，而切片的长度是不固定的，切片中的每一个切片长度都可能是不相同的，所以必须要单独初始化，切片初始化部分修改为如下代码即可。

```go
slices := make([][]int, 5)
for i := 0; i < len(slices); i++ {
   slices[i] = make([]int, 5)
}
```

最终输出结果为

```
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]

[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
```

<br>

## 拓展表达式

::: tip

只有切片才能使用拓展表达式

:::

切片与数组都可以使用简单表达式来进行切割，但是拓展表达式只有切片能够使用，该特性于Go1.2版本添加，主要是为了解决切片共享底层数组的读写问题，主要格式为如下，需要满足关系`low<= high <= max <= cap`，使用拓展表达式切割的切片容量为`max-low`

```go
slice[low:high:max]
```

`low`与`high`依旧是原来的含义不变，而多出来的`max`则指的是最大容量，例如下方的例子中省略了`max`，那么`s2`的容量就是`cap(s1)-low`

```go
s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9
s2 := s1[3:4] // cap = 9 - 3 = 6
```

那么这么做就会有一个明显的问题，`s1`与`s2`是共享的同一个底层数组，在对`s2`进行读写时，有可能会影响的`s1`的数据，下列代码就属于这种情况

```go
s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9
s2 := s1[3:4]                          // cap = 9 - 3 = 6
// 添加新元素，由于容量为6.所以没有扩容，直接修改底层数组
s2 = append(s2, 1)
fmt.Println(s2)
fmt.Println(s1)
```

最终的输出为

```
[4 1]
[1 2 3 4 1 6 7 8 9]
```

可以看到明明是向`s2`添加元素，却连`s1`也一起修改了，拓展表达式就是为了解决此类问题而生的，只需要稍微修改一下就能解决该问题

```go
func main() {
   s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9
   s2 := s1[3:4:4]                        // cap = 4 - 3 = 1
   // 容量不足，分配新的底层数组
   s2 = append(s2, 1)
   fmt.Println(s2)
   fmt.Println(s1)
}
```

 现在得到的结果就是正常的

```
[4 1]
[1 2 3 4 5 6 7 8 9]
```
