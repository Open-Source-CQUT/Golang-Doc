

# 接口

接口是一个非常重要的概念，它描述了一组抽象的规范，而不提供具体的实现。对于项目而言会使得代码更加优雅可读，对于开发者而言也会减少很多心智负担，代码风格逐渐形成了规范，于是就有了现在人们所推崇的面向接口编程。



## 概念

Go关于接口的发展历史有一个分水岭，在Go1.17及以前，官方在参考手册中对于接口的定义为：**一组方法的集合**。

> *An interface type specifies a method set called its interface*. 

接口实现的定义为

> *A variable of interface type can store a value of any type with a method set that is any superset of the interface. Such a type is said to implement the interface*

翻译过来就是，当一个类型的方法集是一个接口的方法集的超集时，且该类型的值可以由该接口类型的变量存储，那么称该类型实现了该接口。

不过在Go1.18时，关于接口的定义发生了变化，接口定义为：**一组类型的集合**。

> An interface type defines a *type set*.

接口实现的定义为

> *A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface*

翻译过来就是，当一个类型位于一个接口的类型集内，且该类型的值可以由该接口类型的变量存储，那么称该类型实现了该接口。并且还给出了如下的额外定义。

> 当如下情况时，可以称类型T实现了接口I
>
> - T不是一个接口，并且是接口I类型集中的一个元素
> - T是一个接口，并且T的类型集是接口I类型集的一个子集
>
> 如果T实现了一个接口，那么T的值也实现了该接口。

Go在1.18最大的变化就是加入了泛型，新接口定义就是为了泛型而服务的，不过一点也不影响之前接口的使用，同时接口也分为了两类，

- 基本接口(`Basic Interface`)：**只包含方法集**的接口就是基本接口
- 通用接口(`General Interface`)：**只要包含类型集**的接口就是通用接口

什么是方法集，方法集就是一组方法的集合，同样的，类型集就是一组类型的集合。

::: tip

这一堆概念很死板，理解的时候要根据代码来思考。

:::



<br/>

## 基本接口

前面讲到了基本接口就是方法集，就是一组方法的集合。

### 声明

先来看看接口长什么样子。

```go
type Person interface {
	Say(string) string
	Walk(int)
}
```

这是一个`Person`接口，有两个对外暴露的方法`Walk`和`Say`，在接口里，函数的参数名变得不再重要，当然如果想加上参数名和返回值名也是允许的。

### 初始化

仅仅只有接口是无法被初始化的，因为它仅仅只是一组规范，并没有具体的实现，不过可以被声明。

```go
func TestInit(t *testing.T) {
   var person Person
   fmt.Println(person)
}
```

输出

```
<nil>
```

### 实现

先来看一个例子，一个建筑公司想一种特殊规格的起重机，于是给出了起重机的特殊规范和图纸，并指明了起重机应该有起重和吊货的功能，**建筑公司并不负责造起重机，只是给出了一个规范，这就叫接口**，于是公司A接下了订单，根据自家公司的独门技术造出了绝世起重机并交给了建筑公司，建筑公司不在乎是用什么技术实现的，也不在乎什么绝世起重机，只要能够起重和吊货就行，仅仅只是当作一台普通起重机来用，**根据规范提供具体的功能，这就叫实现**，。只**根据接口的规范来使用功能，屏蔽其内部实现，这就叫面向接口编程**。过了一段时间，绝世起重机出故障了，公司A也跑路了，于是公司B依据规范造了一台更厉害的巨无霸起重机，由于同样具有起重和吊货的功能，可以与绝世起重机无缝衔接，并不影响建筑进度，建筑得以顺利完成，**内部实现改变而功能不变，不影响之前的使用，可以随意替换，这就是面向接口编程的好处。**

<br>

接下来会用Go描述上述情形

```go
// 起重机接口
type Crane interface { 
	JackUp() string
	Hoist() string
}

// 起重机A
type CraneA struct {
	work int //内部的字段不同代表内部细节不一样
}

func (c CraneA) Work() {
	fmt.Println("使用技术A")
}
func (c CraneA) JackUp() string {
	c.Work()
	return "jackup"
}

func (c CraneA) Hoist() string {
	c.Work()
	return "hoist"
}

// 起重机B
type CraneB struct {
	boot string
}

func (c CraneB) Boot() {
	fmt.Println("使用技术B")
}

func (c CraneB) JackUp() string {
	c.Boot()
	return "jackup"
}

func (c CraneB) Hoist() string {
	c.Boot()
	return "hoist"
}

type ConstructionCompany struct {
	Crane Crane // 只根据Crane类型来存放起重机
}

func (c *ConstructionCompany) Build() {
	fmt.Println(c.Crane.JackUp())
	fmt.Println(c.Crane.Hoist())
	fmt.Println("建筑完成")
}

func TestInterfacesImplements(t *testing.T) {
	// 使用起重机A
	company := ConstructionCompany{CraneA{}}
	company.Build()
	fmt.Println()
	// 更换起重机B
	company.Crane = CraneB{}
	company.Build()
}
```

输出

```
使用技术A
jackup
使用技术A
hoist
建筑完成

使用技术B
jackup
使用技术B
hoist
建筑完成
```

上面例子中，可以观察到接口的实现是隐式的，也对应了官方对于基本接口实现的定义：方法集是接口方法集的超集，所以在Go中，实现一个接口不需要`implements`关键字显式的去指定要实现哪一个接口，只要是实现了一个接口的全部方法，那就是实现了该接口。有了实现之后，就可以初始化接口了，建筑公司结构体内部声明了一个`Crane`类型的成员变量，可以保存所有实现了`Crane`接口的值，由于是`Crane` 类型的变量，所以能够访问到的方法只有`JackUp` 和`Hoist`，内部的其他方法例如`Work`和`Boot`都无法访问。

<br>

之前提到过任何类型都可以拥有方法，那么根据实现的定义，任何类型也可以实现接口，下面举几个比较特殊的例子。

```go
type Person interface {
   Say(string) string
   Walk(int)
}

type Man interface {
   Exercise()
   Person
}
```

`Man`接口方法集是`Person`的超集，所以`Man`也实现了接口`Person`，不过这更像是一种"继承"。

```go
type Number int

func (n Number) Say(s string) string {
	return "bibibibibi"
}

func (n Number) Walk(i int) {
	fmt.Println("can not walk")
}
```

类型`Number`的底层类型是`int`，虽然这放在其他语言中看起来很离谱，但`Number`的方法集确实是`Person` 的超集，所以也算实现。

```go
type Func func()

func (f Func) Say(s string) string {
	f()
	return "bibibibibi"
}

func (f Func) Walk(i int) {
	f()
	fmt.Println("can not walk")
}

func TestFuncImplements(t *testing.T) {
	var function Func
	function = func() {
		fmt.Println("do somthing")
	}
	function()
}
```

同样的，函数类型也可以实现接口。

<br/>

## 空接口

```go
type Any interface{

}
```

`Any`接口内部没有方法集合，根据实现的定义，所有类型都是`Any`接口的的实现，因为所有类型的方法集都是空集的超集，所以`Any`接口可以保存任何类型的值。

```go
func TestEmptyInterfaces(t *testing.T) {
	var anything Any

	anything = 1
	println(anything)
	fmt.Println(anything)

	anything = "something"
	println(anything)
	fmt.Println(anything)
	
	anything = complex(1, 2)
	println(anything)
	fmt.Println(anything)

	anything = 1.2
	println(anything)
	fmt.Println(anything)

	anything = []int{}
	println(anything)
	fmt.Println(anything)

	anything = map[string]int{}
	println(anything)
	fmt.Println(anything)
}
```

输出

```
(0xe63580,0xeb8b08)
1
(0xe63d80,0xeb8c48)
something
(0xe62ac0,0xeb8c58)
(1+2i)
(0xe62e00,0xeb8b00)
1.2
(0xe61a00,0xc0000080d8)
[]
(0xe69720,0xc00007a7b0)
map[]
```

通过输出会发现，两种输出的结果不一致，其实接口内部可以看成是一个由`(val,type)`组成的元组，`type`是具体类型，在调用方法时会去调用具体类型的具体值。

```go
interface{}
```

这也是一个空接口，不过是一个匿名空接口，在开发时通常会使用匿名空接口来表示接收任何类型的值，例子如下

```go
func TestAnonymousEmptyInterfaces(t *testing.T) {
   DoSomething(map[int]string{})
}

func DoSomething(anything interface{}) interface{} {
   return anything
}
```

在后续的更新中，官方提出了另一种解决办法，为了方便起见，可以使用`any`来替代`interace{}`，两者是完全等价的，因为前者仅仅只是一个类型别名，如下

```go
type any = interface{}
```



## 类型推断

由于空接口可以接收任意类型的值，经常会出现需要判断其原类型，假如事先就知道其底层类型，就可以使用**类型断言**，语法格式如下，例子如下

```go
func TestTypeAssert(t *testing.T) {
   var anything any
   anything = 10
   if intVal, ok := anything.(int); ok {
      fmt.Println(intVal)
   } else {
      fmt.Println("不是整型")
   }
}
```

类型断言有两个返回值，第一个返回值是接口存储的底层值，第二个返回值是断言是否成功

<br/>

假如事先不知道其类型，就可以使用**类型选择**，需要结合`switch`语句来使用，例子如下

```go
func TestTypeSwitch(t *testing.T) {
   var anything any
   anything = 10
   switch anything.(type) {
   case int:
      fmt.Println("是整型")
   case float64:
      fmt.Println("是浮点数")
   case complex128:
      fmt.Println("是复数")
   }
}
```



## 通用接口

通用接口就是为了泛型服务的，所以掌握了泛型，就掌握了通用接口，请移步[泛型教程](20.generic.md)
